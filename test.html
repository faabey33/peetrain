<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Deutsche Bahn API Example</title>
</head>

<body>
  <h1>Deutsche Bahn API Example</h1>
  <p>Open the browser console to see the results.</p>

  <table id="timetable">
    <thead>
      <tr>
        <th>Type</th>
        <th>Number</th>
        <th>Platform</th>
        <th>Arrival</th>
        <th>Departure</th>
        <th>Delta(min)</th>
      </tr>
    </thead>

  </table>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.4.min.js"
    integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script>
    function XmlListConfig(xml) {
      var obj = {};
      if (xml.nodeType == 1) {
        if (xml.attributes.length > 0) {
          obj["@attributes"] = {};
          for (var j = 0; j < xml.attributes.length; j++) {
            var attribute = xml.attributes.item(j);
            obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
          }
        }
      } else if (xml.nodeType == 3) {
        obj = xml.nodeValue;
      }
      if (xml.hasChildNodes()) {
        for (var i = 0; i < xml.childNodes.length; i++) {
          var item = xml.childNodes.item(i);
          var nodeName = item.nodeName;
          if (typeof (obj[nodeName]) == "undefined") {
            obj[nodeName] = XmlListConfig(item);
          } else {
            if (typeof (obj[nodeName].push) == "undefined") {
              var old = obj[nodeName];
              obj[nodeName] = [];
              obj[nodeName].push(old);
            }
            obj[nodeName].push(XmlListConfig(item));
          }
        }
      }
      return obj;
    }

    function updateTable(data) {

      const keys = ['c', 'n', 'pp_dp', 'pt_ar', 'pt_dp', 'delta_minutes']
      // Get a reference to the table element
      const table = document.getElementById("timetable");
      
      // Loop through the array of data
      for (let i = 0; i < data.length; i++) {
        
        // Create a new row for the table
        const newRow = table.insertRow(-1);

        for (const key of keys) {
          var cell = newRow.insertCell(-1);
          cell.textContent = data[i][key]

        }
      }
    }

    let finalData;

    async function run() {

      const now = moment();
      const pattern = "BLS";
      const YYMMDD = now.format("YYMMDD");
      let HH = now.format("HH");
      let evas;
      let stationsArray;

      const url = `https://iris.noncd.db.de/iris-tts/timetable/station/${pattern}`;

      try {
        const response = await $.ajax({
          url: url,
          type: 'GET',
        });

        console.log(response);
        const xmljson = XmlListConfig(response);
        stationsArray = xmljson.stations;

        // One station can have multiple eva ids e.g Berlin HBF: [Berlin HBF, Berlin HBF S, Berlin HBF tief]
        evas = [stationsArray.station['@attributes'].eva];
        console.log(evas);
      } catch (error) {
        console.error('Request failed. Returned status of ' + error.status);
      }

      async function transformXMLToNiceJSON(response) {

        if (!response) return [];

        const timetableArray = XmlListConfig(response);

        if (!(timetableArray.timetable.hasOwnProperty("@attributes"))) return [];

        const timetableArray_s = timetableArray.timetable.s;

        const filteredData = timetableArray_s.filter(row => row.ar && row.dp);

        const newData = filteredData.map(row => {
          const arDateTime = moment(row.ar['@attributes'].pt, "YYMMDDHHmm").toDate();
          const dpDateTime = moment(row.dp['@attributes'].pt, "YYMMDDHHmm").toDate();

          return {
            c: row.tl['@attributes'].c,
            n: row.tl['@attributes'].n,
            pp_ar: row.ar['@attributes'].pp,
            pp_dp: row.dp['@attributes'].pp,
            pt_ar: arDateTime,
            pt_dp: dpDateTime,
          };
        });

        return newData;
      }

      async function getTimeTable(evaArray, YYMMDD, HH) {
        let fullData = [];

        for (let hourOffset = -1; hourOffset < 2; hourOffset++) {
          HH = moment(Date.now()).add({ hours: hourOffset }).format("HH");
          for (const eva of evaArray) {
            const url = `https://iris.noncd.db.de/iris-tts/timetable/plan/${eva}/${YYMMDD}/${HH}`;
            try {
              const response = await $.ajax({
                url: url,
                type: 'GET',
              });
              fullData = fullData.concat(await transformXMLToNiceJSON(response));

            } catch (e) {
              console.log(e);
            }

          }
        }

        const sortedData = fullData.sort((a, b) => a.pt_ar - b.pt_ar);
        const filteredData = sortedData.filter(a => moment(a.pt_dp) > now);

        let finalData = filteredData.map(row => ({
          c: row.c,
          n: row.n,
          // pp_ar: row.pp_ar,
          pp_dp: row.pp_dp,
          pt_ar: moment(row.pt_ar).format("HH:mm"),
          pt_dp: moment(row.pt_dp).format("HH:mm"),
          delta_minutes: Math.round((row.pt_dp - row.pt_ar) / (1000 * 60)),
        }));

        finalData = finalData.filter(a => a.delta_minutes > 2)

        console.table(finalData);
        return finalData
      }
      
      finalData = await getTimeTable(evas, YYMMDD, HH);
      updateTable(finalData);

    }
    run();
  </script>
</body>

</html>